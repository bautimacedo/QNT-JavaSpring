# v0.7.0 — Compras: imagen de la factura

**VERSIÓN:** v0.7.0  
**SLUG:** compra-imagen-factura  
**DEPENDENCIAS:** v0.6.0 (controller compras)  
**ESTIMACIÓN:** 1h  
**PRIORIDAD:** alta

---

## Descripción

Las compras deben poder llevar una **foto de la factura**. Se agrega un campo opcional en la entidad `Compra` para almacenar la imagen (en BD como binario) y dos endpoints en el `CompraRestController`: uno para **subir** la imagen (PUT con multipart) y otro para **obtenerla** (GET que devuelve el contenido de la imagen).

---

## PASO 0 — Contexto previo a leer

- `gestion/src/main/java/com/gestion/qnt/model/Compra.java`
- `gestion/src/main/java/com/gestion/qnt/controller/CompraRestController.java`
- `gestion/src/main/java/com/gestion/qnt/model/business/interfaces/ICompraBusiness.java`

---

## PASO 1 — Campo en la entidad Compra

En `Compra.java` agregar un campo opcional para la imagen de la factura:

- Nombre sugerido: `imagenFactura` (o `fotoFactura`).
- Tipo: `byte[]`.
- Anotaciones JPA: `@Lob`, `@Column(nullable = true)` (o `@Basic(optional = true)`).
- En la tabla: columna tipo BYTEA (PostgreSQL) / BLOB; Hibernate lo resuelve con `@Lob`.
- Para que no se serialice en JSON al devolver la compra completa (evitar payload enorme), usar `@JsonIgnore` en ese getter o anotar el campo con `@JsonIgnore`.

**Verificación:** compilación OK; migración/DDL con `spring.jpa.hibernate.ddl-auto=update` crea la columna sin romper datos existentes.

---

## PASO 2 — Endpoint para subir la imagen (PUT /compras/{id}/imagen)

En `CompraRestController`:

- **Ruta:** `PUT /api/qnt/v1/compras/{id}/imagen`
- **Parámetro:** `@RequestParam("file") MultipartFile file` (o `@RequestPart("file") MultipartFile file`).
- **Lógica:** cargar la compra por `id` (si no existe → 404). Leer el contenido del archivo con `file.getBytes()`, setearlo en `compra.setImagenFactura(...)`, guardar con `compraBusiness.update(compra)`. Devolver 200 OK (o 204) sin body, o un JSON mínimo `{"ok": true}`.
- **Seguridad:** misma que el resto del controller (JWT requerido; mismo @PreAuthorize si se usa).
- **Tamaño máximo:** configurar si hace falta en `application.properties` (ej. `spring.servlet.multipart.max-file-size=10MB`) para evitar subidas enormes.

**Verificación:** PUT con multipart a `/api/qnt/v1/compras/1/imagen` con un JPG/PNG actualiza la compra 1 y al consultar el GET de imagen se devuelve esa imagen.

---

## PASO 3 — Endpoint para obtener la imagen (GET /compras/{id}/imagen)

En `CompraRestController`:

- **Ruta:** `GET /api/qnt/v1/compras/{id}/imagen`
- **Respuesta:** si la compra existe y tiene `imagenFactura` no nulo ni vacío, devolver el contenido con `Content-Type: image/jpeg` (o `image/png` / `application/octet-stream` si no se puede inferir). Usar `ResponseEntity<byte[]>` con `HttpHeaders` para setear el content-type y opcionalmente content-disposition.
- Si la compra no existe → 404. Si la compra existe pero no tiene imagen → 404 (o 204 No Content), según criterio del equipo.
- **Seguridad:** JWT requerido, igual que el resto.

**Verificación:** GET `/api/qnt/v1/compras/1/imagen` con token devuelve la imagen subida en el paso anterior.

---

## PASO 4 — Documentación y commit

- Actualizar `docs/COMO_PROBAR_API.md`: en la sección Compras, añadir cómo subir y obtener la imagen (ejemplo con curl: multipart para PUT, GET para descargar).
- Commit y tag:

```bash
VERSION="v0.7.0"
SLUG="compra-imagen-factura"

git add gestion/src/main/java/com/gestion/qnt/model/Compra.java \
        gestion/src/main/java/com/gestion/qnt/controller/CompraRestController.java \
        docs/COMO_PROBAR_API.md

git commit --no-verify -m "feat(compras): imagen de la factura en Compra

- Campo imagenFactura (byte[] @Lob) en Compra, @JsonIgnore en respuesta
- PUT /compras/{id}/imagen (multipart) para subir imagen
- GET /compras/{id}/imagen para obtener imagen
- Documentación en COMO_PROBAR_API"

git tag -a "${VERSION}" -m "Release v0.7.0: Compras imagen factura"
```

---

## Verificación final

- [ ] Build sin errores.
- [ ] Columna de imagen en tabla compras (update/create-drop según entorno).
- [ ] PUT /compras/{id}/imagen con multipart guarda la imagen.
- [ ] GET /compras/{id}/imagen devuelve la imagen con content-type correcto.
- [ ] GET /compras/{id} (compra completa) no incluye el byte[] en JSON (@JsonIgnore).
- [ ] Sin token → 401 en ambos endpoints.

---

## Notas

- Si más adelante se quiere almacenar en sistema de archivos o objeto (S3), se puede cambiar la implementación manteniendo la misma API (PUT/GET por id).
- Opcional: aceptar también Content-Type de la imagen para guardar y devolver el mismo (ej. image/png vs image/jpeg).
