# v0.5.0 ‚Äî Controladores REST de Usuario y Role (CRUD + alta de usuario para probar login)

**VERSI√ìN:** v0.5.0  
**SLUG:** controllers-usuario-role  
**DEPENDENCIAS:** v0.4.0 (seguridad JWT y AuthRestController)  
**ESTIMACI√ìN:** 2h  
**PRIORIDAD:** alta

---

## Origen

> üóÇÔ∏è *Prompt generado por el Agente PM.*  
> *El programador indic√≥ c√≥mo probar el flujo (crear usuario con contrase√±a hasheada, login, GET /auth/me). El cliente pidi√≥ un controller que permita crear usuario y gestionar usuarios/roles, siguiendo el patr√≥n de referencia (UserRestController y RoleRestController). Objetivo: tener listo el back para levantar y mandar POSTs y probar.*

---

## Descripci√≥n

Implementar dos controladores REST en el m√≥dulo `gestion`:

1. **UsuarioRestController** ‚Äî Crear usuario (POST con password en claro, hasheando en backend), listar, buscar por email, cambiar contrase√±a, desactivar/activar usuario, asignar y quitar roles. Rutas bajo `/api/qnt/v1/usuarios`. Protecci√≥n con `@PreAuthorize("hasRole('ADMIN')")` (o el rol que use el proyecto) en los endpoints que lo requieran; el alta de usuario puede requerir ADMIN para no dejar registro abierto.
2. **RoleRestController** ‚Äî Listar roles, buscar por codigo, alta (POST) y actualizaci√≥n (PUT). Rutas bajo `/api/qnt/v1/roles`. Protecci√≥n con `@PreAuthorize("hasRole('ADMIN')")` en todos los m√©todos.

Adem√°s, extender **IUsuarioBusiness** (y **UsuarioBusiness**) con los m√©todos que hoy no existen: `changePassword`, `disable`, `enable`, `addRole`, `removeRole`. En la entidad **Usuario** agregar el campo **activo** (Boolean, default true) si no existe, para soportar disable/enable.

**Patr√≥n de referencia:** Los archivos UserRestController y RoleRestController del otro proyecto (paquete project.iw3.iw3.auth.controller). Adaptar a paquetes `com.gestion.qnt`, entidades `Usuario` y `Role` (Role tiene `codigo` y `nombre`; en este proyecto el identificador del rol es `codigo`), y constantes `ApiConstants.URL_BASE` = `/api/qnt/v1`.

**Objetivo de prueba:** Poder crear un usuario (POST con email y password en claro; el backend hashea la password), luego hacer login (POST /api/qnt/v1/auth/login) y GET /api/qnt/v1/auth/me con el token.

---

## PASO 0 ‚Äî Contexto previo a leer

> ‚ö†Ô∏è Si ven√≠s del AGENTE_WORKFLOW.md, saltear este paso.

Leer sin ejecutar nada:

- `gestion/src/main/java/com/gestion/qnt/config/ApiConstants.java` ‚Äî URL_BASE y rutas.
- `gestion/src/main/java/com/gestion/qnt/model/Usuario.java` y `model/Role.java` ‚Äî campos actuales.
- `gestion/src/main/java/com/gestion/qnt/model/business/interfaces/IUsuarioBusiness.java` y `IRoleBusiness.java` ‚Äî m√©todos existentes.
- `gestion/src/main/java/com/gestion/qnt/security/controller/AuthRestController.java` ‚Äî ruta de login y uso de PasswordEncoder.

---

## PASO 0.5 ‚Äî Configurar conexi√≥n a la base de datos

Configurar la aplicaci√≥n para que use la base de datos **qnt_spring** (PostgreSQL) del servidor.

En `gestion/src/main/resources/application.properties` (o en `application-dev.properties` si se usa perfil `dev`) definir:

- **URL:** `jdbc:postgresql://localhost:5432/qnt_spring`  
  Si PostgreSQL est√° en otro host (ej. el servidor mostrado en el Object Explorer), reemplazar `localhost` por ese host (ej. `servidor_clinica` o la IP correspondiente).
- **Usuario:** `postgres`
- **Contrase√±a:** `postgres` (contrase√±a del usuario postgres del servidor PostgreSQL).

Ejemplo de propiedades:

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/qnt_spring
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver
```

Si ya existen variables de entorno o placeholders (ej. `${DB_URL:...}`), ajustar el valor por defecto para que apunte a `qnt_spring`:

```properties
spring.datasource.url=${DB_URL:jdbc:postgresql://localhost:5432/qnt_spring}
spring.datasource.username=${DB_USERNAME:postgres}
spring.datasource.password=${DB_PASSWORD:postgres}
```

**Verificaci√≥n:** Al arrancar la aplicaci√≥n (`mvn -f gestion/pom.xml spring-boot:run` o desde el IDE), la conexi√≥n a la BD debe establecerse sin error. Si las tablas a√∫n no existen, usar `spring.jpa.hibernate.ddl-auto=update` en desarrollo para que Hibernate las cree; en producci√≥n usar `validate`.

---

## PASO 1 ‚Äî Campo activo en Usuario y m√©todos nuevos en IUsuarioBusiness / UsuarioBusiness

**1.1** En la entidad **Usuario** agregar, si no existe, el campo:

- **activo** (Boolean, nullable = false, valor por defecto true). Permite desactivar/activar el usuario sin borrarlo.

**1.2** En **IUsuarioBusiness** agregar:

- `void changePassword(String email, String oldPassword, String newPassword, PasswordEncoder encoder) throws NotFoundException, BusinessException;` ‚Äî validar que la contrase√±a actual coincida (encoder.matches), luego setear la nueva contrase√±a hasheada y hacer update. Si la contrase√±a actual no coincide se puede lanzar una excepci√≥n (ej. BadPasswordException o usar NotFoundException/BusinessException con mensaje).
- `void disable(String email) throws NotFoundException, BusinessException;` ‚Äî cargar usuario por email, setear activo = false, update.
- `void enable(String email) throws NotFoundException, BusinessException;` ‚Äî cargar usuario por email, setear activo = true, update.
- `Usuario addRole(Role role, Usuario user) throws NotFoundException, BusinessException;` ‚Äî agregar el rol a la lista de roles del usuario (evitando duplicados) y guardar.
- `Usuario removeRole(Role role, Usuario user) throws NotFoundException, BusinessException;` ‚Äî quitar el rol de la lista del usuario y guardar.

**1.3** Implementar estos m√©todos en **UsuarioBusiness**. Para changePassword: si `!encoder.matches(oldPassword, user.getPassword())` lanzar excepci√≥n (por ejemplo `BadPasswordException` o `BusinessException` con mensaje "Contrase√±a anterior incorrecta"). La nueva contrase√±a debe guardarse hasheada: `user.setPassword(encoder.encode(newPassword)); update(user);`.

Opcional: crear **BadPasswordException** en `com.gestion.qnt.security` (o en model.business.exceptions) si no existe, para usar en changePassword.

**Verificaci√≥n:** El proyecto compila. Usuario tiene el campo activo; IUsuarioBusiness y UsuarioBusiness tienen los cinco m√©todos nuevos.

---

## PASO 2 ‚Äî UsuarioRestController

Crear en `com.gestion.qnt.controller` (o `com.gestion.qnt.security.controller`) la clase **UsuarioRestController**:

- **@RequestMapping**: `ApiConstants.URL_BASE + "/usuarios"` (ej. `/api/qnt/v1/usuarios`).
- Inyectar: **IUsuarioBusiness**, **IRoleBusiness**, **PasswordEncoder**.

Endpoints:

| M√©todo | Ruta | Descripci√≥n | Autorizaci√≥n |
|--------|------|-------------|--------------|
| GET | (base) | Listar todos los usuarios | @PreAuthorize("hasRole('ADMIN')") |
| GET | /search?email= | Cargar usuario por email | @PreAuthorize("hasRole('ADMIN')") |
| POST | (base) | **Crear usuario** (body: nombre, apellido, email, password, opcional roleIds o roleCodigos) | @PreAuthorize("hasRole('ADMIN')") |
| PUT | (base) o /{id} | Actualizar usuario (body con campos a actualizar; no permitir cambiar password por aqu√≠, usar change-password) | @PreAuthorize("hasRole('ADMIN')") |
| POST | /change-password | Cambiar contrase√±a (body: email, oldPassword, newPassword) | @PreAuthorize("hasRole('ADMIN') or hasRole('USER')") o solo el propio usuario seg√∫n criterio |
| PUT | /disable?email= | Desactivar usuario (activo = false) | @PreAuthorize("hasRole('ADMIN')") |
| PUT | /enable?email= | Activar usuario (activo = true) | @PreAuthorize("hasRole('ADMIN')") |
| PUT | /assign-role | Asignar rol (body: email, roleCodigo) | @PreAuthorize("hasRole('ADMIN')") |
| PUT | /remove-role | Quitar rol (body: email, roleCodigo) | @PreAuthorize("hasRole('ADMIN')") |

**Crear usuario (POST):**  
Recibir en el body (JSON) al menos: `nombre`, `apellido`, `email`, `password` (en claro). Opcional: `roleIds` (array de IDs de Role) o `roleCodigos` (array de c√≥digos, ej. ["ROLE_ADMIN"]). Antes de llamar a `usuarioBusiness.add(usuario)`, hashear la contrase√±a: `usuario.setPassword(passwordEncoder.encode(plainPassword))`. Si se env√≠an roles, cargar los Role por id o codigo, setear `usuario.setRoles(lista)` y luego add. Respuesta: 201 Created con el usuario creado (sin devolver el password en el JSON, o devolverlo hasheado; ideal no exponer password).

**Buscar por email:**  
GET `/search?email=email@ejemplo.com` ‚Äî llamar `usuarioBusiness.load(email)` y devolver 200 OK o 404 si no existe.

**Change password:**  
Body JSON: `email` (o usernameOrEmail), `oldPassword`, `newPassword`. Llamar `usuarioBusiness.changePassword(...)`. En caso de contrase√±a anterior incorrecta devolver 400 Bad Request con mensaje claro.

**Assign/Remove role:**  
Body JSON: `email` (o usernameOrEmail), `roleCodigo` (String, ej. "ROLE_ADMIN"). Cargar usuario por email, cargar rol por codigo (`roleBusiness.load(codigo)`), llamar `usuarioBusiness.addRole(role, user)` o `removeRole(role, user)`. Devolver el usuario actualizado.

Manejo de excepciones: **NotFoundException** ‚Üí 404, **FoundException** (ej. email duplicado en add) ‚Üí 409 o 400, **BusinessException** u otra ‚Üí 500 con mensaje. Reutilizar el patr√≥n del AuthRestController o del proyecto (BaseRestController / est√°ndar de respuesta) si existe.

**Verificaci√≥n:** Compilaci√≥n correcta y rutas bajo `/api/qnt/v1/usuarios` como se defini√≥.

---

## PASO 3 ‚Äî RoleRestController

Crear en el mismo paquete la clase **RoleRestController**:

- **@RequestMapping**: `ApiConstants.URL_BASE + "/roles"` (ej. `/api/qnt/v1/roles`).
- Inyectar: **IRoleBusiness**.

Endpoints:

| M√©todo | Ruta | Descripci√≥n | Autorizaci√≥n |
|--------|------|-------------|--------------|
| GET | (base) | Listar todos los roles | @PreAuthorize("hasRole('ADMIN')") |
| GET | /search?codigo= | Cargar rol por codigo | @PreAuthorize("hasRole('ADMIN')") |
| POST | (base) | Crear rol (body: codigo, nombre opcional) | @PreAuthorize("hasRole('ADMIN')") |
| PUT | (base) o /{id} | Actualizar rol (body: id, codigo, nombre) | @PreAuthorize("hasRole('ADMIN')") |

**Crear rol (POST):**  
Body JSON: `codigo` (obligatorio, ej. "ROLE_ADMIN"), `nombre` (opcional, ej. "Administrador"). Crear instancia de Role, setear campos, llamar `roleBusiness.add(role)`. Respuesta 201 Created.

**Buscar por codigo:**  
GET `/search?codigo=ROLE_ADMIN` ‚Äî `roleBusiness.load(codigo)` ‚Üí 200 OK o 404.

Manejo de excepciones: NotFoundException ‚Üí 404, FoundException (codigo duplicado) ‚Üí 409/400, BusinessException ‚Üí 500.

**Verificaci√≥n:** Compilaci√≥n correcta y rutas bajo `/api/qnt/v1/roles`.

---

## PASO 4 ‚Äî SecurityConfiguration: permitir acceso a las nuevas rutas

Las rutas `/api/qnt/v1/usuarios/**` y `/api/qnt/v1/roles/**` no deben estar en permitAll; deben requerir autenticaci√≥n (y los m√©todos ya restringen por rol con @PreAuthorize). Confirmar que en **SecurityConfiguration** no se agregue ninguna regla que deje estas rutas p√∫blicas. Por defecto, `anyRequest().authenticated()` aplica y los controladores exigen ADMIN (o el rol configurado). Si el proyecto usa nombres de rol con prefijo "ROLE_", en @PreAuthorize usar por ejemplo `hasRole('ADMIN')` (Spring a√±ade el prefijo) o `hasAuthority('ROLE_ADMIN')` seg√∫n corresponda.

**Verificaci√≥n:** Una petici√≥n a GET /api/qnt/v1/usuarios sin token devuelve 401.

---

## PASO 5 ‚Äî C√≥mo probar (documentar en el prompt o en README)

Flujo sugerido para probar:

1. **Crear un rol** (si no existe en BD):  
   POST `/api/qnt/v1/roles` con body `{"codigo":"ROLE_ADMIN","nombre":"Administrador"}`.  
   (Requiere estar autenticado como ADMIN; si es la primera vez, insertar un rol y un usuario admin por SQL o con un script de datos iniciales.)

2. **Primer usuario admin (si la BD est√° vac√≠a):**  
   - Obtener hash de contrase√±a: GET `/api/qnt/v1/demo/encodepass?password=miClave` (p√∫blico).  
   - Insertar en BD un usuario con ese password hasheado y asignarle el rol ROLE_ADMIN (por script SQL o por un loader), **o** si se implementa un endpoint de bootstrap que permita crear el primer usuario sin estar logueado, usarlo una sola vez.

   Alternativa para no usar SQL: dejar POST `/api/qnt/v1/usuarios` permitAll solo cuando no exista ning√∫n usuario (l√≥gica condicional en SecurityConfiguration o en un filtro). Si no se implementa bootstrap, documentar: "Para el primer usuario, insertar manualmente en la tabla usuarios con password hasheado (usar /demo/encodepass) y en usuario_roles asignar el rol ADMIN."

3. **Login:**  
   POST `/api/qnt/v1/auth/login` con `username=email@ejemplo.com` y `password=miClave` (form o query param). Respuesta 200 con el token JWT en el cuerpo.

4. **Usuario actual:**  
   GET `/api/qnt/v1/auth/me` con header `Authorization: Bearer <token>`. Respuesta 200 con el principal (AuthUser).

5. **Crear otro usuario (como ADMIN):**  
   POST `/api/qnt/v1/usuarios` con header `Authorization: Bearer <token>` y body:  
   `{"nombre":"Juan","apellido":"P√©rez","email":"juan@ejemplo.com","password":"otraClave","roleCodigos":["ROLE_USER"]}`.  
   Respuesta 201 con el usuario creado.

6. **Listar usuarios:**  
   GET `/api/qnt/v1/usuarios` con header Authorization. Respuesta 200 con la lista.

7. **Cambiar contrase√±a, disable/enable, assign-role, remove-role:** probar seg√∫n los endpoints definidos arriba.

Incluir esta secci√≥n "C√≥mo probar" al final del prompt o en un comentario en el c√≥digo / README del repo para que quien levante el back pueda seguir estos pasos.

---

## PASO 6 ‚Äî Verificaci√≥n final

- [ ] Usuario tiene campo `activo`; IUsuarioBusiness y UsuarioBusiness implementan changePassword, disable, enable, addRole, removeRole.
- [ ] UsuarioRestController expone: GET list, GET /search?email=, POST create (password hasheada en backend), PUT update, POST /change-password, PUT /disable, PUT /enable, PUT /assign-role, PUT /remove-role.
- [ ] RoleRestController expone: GET list, GET /search?codigo=, POST create, PUT update.
- [ ] Todas las rutas bajo `/api/qnt/v1/usuarios` y `/api/qnt/v1/roles` requieren autenticaci√≥n; los m√©todos usan @PreAuthorize con hasRole('ADMIN') donde corresponda.
- [ ] Build sin errores; arranque de la aplicaci√≥n OK.
- [ ] Documentado o indicado en el prompt el flujo "C√≥mo probar" para crear usuario, login y GET /auth/me.

---

## PASO N ‚Äî Commit y tag

```bash
VERSION="v0.5.0"
SLUG="controllers-usuario-role"

git add gestion/src/main/java/com/gestion/qnt/model/Usuario.java \
       gestion/src/main/java/com/gestion/qnt/model/business/ \
       gestion/src/main/java/com/gestion/qnt/controller/ \
       gestion/src/main/java/com/gestion/qnt/config/SecurityConfiguration.java

git commit --no-verify -m "feat(api): controladores Usuario y Role para CRUD y prueba de login

- Usuario: campo activo; IUsuarioBusiness changePassword, disable, enable, addRole, removeRole
- UsuarioRestController: list, search, create (password hasheada), update, change-password, disable, enable, assign-role, remove-role
- RoleRestController: list, search, create, update
- Rutas /api/qnt/v1/usuarios y /api/qnt/v1/roles protegidas con JWT y PreAuthorize ADMIN"

git tag -a "${VERSION}" -m "Release v0.5.0: Controladores Usuario y Role"
```

(Ajustar rutas de `git add` seg√∫n la estructura real de paquetes.)

---

## Notas

- **Primer usuario admin:** Si no hay ning√∫n usuario en BD, no se puede hacer login. Opciones: (1) script SQL o data loader que cree un rol ROLE_ADMIN y un usuario con password hasheada (usar /demo/encodepass para obtener el hash); (2) endpoint de bootstrap que permita POST /usuarios sin auth solo cuando la tabla usuarios est√© vac√≠a (opcional, no obligatorio en este ticket).
- **Roles:** En este proyecto Role se identifica por `codigo` (ej. ROLE_ADMIN, ROLE_USER). En assign-role y remove-role el body usa `roleCodigo`.
- **Password en create:** El cliente env√≠a la contrase√±a en claro en el POST de creaci√≥n; el backend la hashea con PasswordEncoder antes de guardar.
- **Respuesta de create user:** No devolver el campo password en el JSON de respuesta (o devolver null) por seguridad.
