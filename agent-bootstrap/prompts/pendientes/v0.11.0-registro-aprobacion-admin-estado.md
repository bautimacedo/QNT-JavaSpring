# v0.11.0 — Registro público y aprobación por admin (Opción B: estado explícito)

**VERSIÓN:** v0.11.0  
**SLUG:** registro-aprobacion-admin-estado  
**DEPENDENCIAS:** v0.4.0 (JWT), v0.5.0 (usuarios/roles)  
**ESTIMACIÓN:** 2h  
**PRIORIDAD:** alta

---

## Objetivo

Implementar el flujo **registro → aprobación por admin → login** de forma escalable con un **estado explícito** del usuario. Se agrega un enum `EstadoUsuario` (PENDIENTE_APROBACION, ACTIVO, DESACTIVADO) y un campo `estado` en la entidad `Usuario`. Solo los usuarios con `estado == ACTIVO` pueden hacer login; los demás reciben un mensaje claro. El admin lista usuarios pendientes y aprueba asignando rol (Administrador o Piloto).

---

## PASO 0 — Contexto previo a leer

- `gestion/src/main/java/com/gestion/qnt/model/Usuario.java`
- `gestion/src/main/java/com/gestion/qnt/model/enums/TipoCompra.java` (referencia para crear enum en el mismo paquete)
- `gestion/src/main/java/com/gestion/qnt/security/controller/AuthRestController.java`
- `gestion/src/main/java/com/gestion/qnt/security/custom/CustomAuthenticationManager.java`
- `gestion/src/main/java/com/gestion/qnt/controller/UsuarioRestController.java`
- `gestion/src/main/java/com/gestion/qnt/model/business/interfaces/IUsuarioBusiness.java`
- `gestion/src/main/java/com/gestion/qnt/model/business/UsuarioBusiness.java`
- `gestion/src/main/java/com/gestion/qnt/repository/UsuarioRepository.java`
- `gestion/src/main/java/com/gestion/qnt/config/SecurityConfiguration.java`
- `gestion/src/main/java/com/gestion/qnt/config/ApiConstants.java`

---

## PASO 1 — Enum EstadoUsuario y campo en Usuario

**1.1 Enum**

- Crear `com.gestion.qnt.model.enums.EstadoUsuario` con valores:
  - `PENDIENTE_APROBACION` — recién registrado, sin aprobar
  - `ACTIVO` — puede usar la aplicación
  - `DESACTIVADO` — el admin lo desactivó

**1.2 Entidad Usuario**

- Agregar campo `estado` de tipo `EstadoUsuario`.
- Anotación JPA: `@Enumerated(EnumType.STRING)`, `@Column(name = "estado", nullable = false)` (o length si hace falta).
- Valor por defecto en Java: `EstadoUsuario.ACTIVO` (para no romper datos existentes; los usuarios ya creados se consideran ACTIVO).
- En la base de datos: si ya hay filas en `usuarios`, agregar la columna con valor por defecto `'ACTIVO'` (en PostgreSQL: `ALTER TABLE usuarios ADD COLUMN estado VARCHAR(30) NOT NULL DEFAULT 'ACTIVO';`). Si usan `spring.jpa.hibernate.ddl-auto=update`, Hibernate puede agregar la columna; documentar en el prompt que para datos existentes conviene ejecutar el DEFAULT o migración.
- Mantener el campo `activo` (Boolean) por compatibilidad: al cambiar `estado` sincronizar `activo` (estado == ACTIVO → activo true; si no → activo false) en los métodos que modifican estado, para que código que siga usando `activo` no se rompa.

**Verificación:** Compilación OK; entidad Usuario tiene estado con enum; migración o ddl-auto aplica la columna.

---

## PASO 2 — Registro público (POST /auth/register)

**2.1 Constante y seguridad**

- En `ApiConstants`: `public static final String URL_REGISTER = URL_BASE + "/auth/register";`
- En `SecurityConfiguration`: `.requestMatchers(HttpMethod.POST, ApiConstants.URL_REGISTER).permitAll()`

**2.2 DTO y endpoint**

- Crear `RegisterRequest` (nombre, apellido, email, password) con validaciones necesarias.
- En `AuthRestController`: POST `/api/qnt/v1/auth/register`, body JSON. Si email ya existe → 409 Conflict. Si no: crear `Usuario` con nombre, apellido, email, password (hasheado), **estado = PENDIENTE_APROBACION**, **activo = false**, **roles = lista vacía**. Guardar con `usuarioBusiness.add(usuario)`. Devolver 201 CREATED (sin password en respuesta).

**Verificación:** Registro crea usuario con estado PENDIENTE_APROBACION; email duplicado → 409.

---

## PASO 3 — Login según estado

- En `CustomAuthenticationManager.authenticate`, después de validar contraseña:
  - Si `usuario.getEstado() != EstadoUsuario.ACTIVO`:
    - Si `estado == PENDIENTE_APROBACION` → lanzar `DisabledException("Tu cuenta está pendiente de aprobación por un administrador")`.
    - Si `estado == DESACTIVADO` → lanzar `DisabledException("Tu cuenta está desactivada")`.
    - (Cualquier otro valor → mismo mensaje desactivada o genérico.)
  - Sincronizar: si se usa solo `estado` para la lógica, asegurar que cuando estado sea ACTIVO, `activo` sea true (por si algo más lo lee).
- En `AuthRestController.login`, capturar `DisabledException` y devolver **403 Forbidden** con `e.getMessage()` en el body para que el frontend muestre el texto.

**Verificación:** Login con estado PENDIENTE_APROBACION → 403 con mensaje de pendiente; con DESACTIVADO → 403 con mensaje de desactivada; con ACTIVO → 200 y token.

---

## PASO 4 — Listar pendientes y aprobar (solo ADMIN)

**4.1 Repositorio y negocio**

- En `UsuarioRepository`: `List<Usuario> findByEstado(EstadoUsuario estado);`
- En `IUsuarioBusiness`:
  - `List<Usuario> listPendientes() throws BusinessException;` — devolver `findByEstado(PENDIENTE_APROBACION)` (o llamar a repository y filtrar por estado).
  - `Usuario aprobar(Long usuarioId, String roleCodigo) throws NotFoundException, BusinessException;` — cargar usuario, validar que estado sea PENDIENTE_APROBACION (si no, opcionalmente lanzar BusinessException "El usuario no está pendiente de aprobación"). Cargar rol por codigo; setear `usuario.setEstado(EstadoUsuario.ACTIVO)`, `usuario.setActivo(true)`; asignar el rol (addRole o setear lista); guardar (update). Devolver usuario actualizado.
- En `UsuarioBusiness`: implementar `listPendientes()` y `aprobar(...)` con `@Transactional` donde haga falta (p. ej. readOnly en listPendientes).

**4.2 Desactivar / activar (sincronizar con estado)**

- En `UsuarioBusiness.disable`: además de `setActivo(false)`, setear `setEstado(EstadoUsuario.DESACTIVADO)`.
- En `UsuarioBusiness.enable`: además de `setActivo(true)`, setear `setEstado(EstadoUsuario.ACTIVO)`.

**4.3 Controller**

- **GET /usuarios/pendientes** — `@PreAuthorize("hasRole('ADMIN')")`, devolver `usuarioBusiness.listPendientes()`. 200 con la lista.
- **PUT /usuarios/{id}/aprobar** — `@PreAuthorize("hasRole('ADMIN')")`, body DTO con `roleCodigo` (ej. `AprobarUsuarioRequest`). Llamar `usuarioBusiness.aprobar(id, request.getRoleCodigo())`. 200 con usuario actualizado. Validar que `roleCodigo` sea uno permitido (ROLE_ADMIN, ROLE_PILOTO, ROLE_USER) si se desea.
- 404 si usuario o rol no existe.

**Verificación:** GET /usuarios/pendientes devuelve solo PENDIENTE_APROBACION. PUT /usuarios/{id}/aprobar con roleCodigo activa y asigna rol; el usuario puede hacer login. Disable/Enable actualizan estado y activo.

---

## PASO 5 — Documentación y migración de datos

- Actualizar `docs/COMO_PROBAR_API.md`: Registro (POST /auth/register), Login (403 pendiente/desactivado), GET /usuarios/pendientes, PUT /usuarios/{id}/aprobar.
- Si la tabla `usuarios` ya tiene datos, documentar o añadir en el prompt: ejecutar migración o SQL para agregar columna con default:  
  `ALTER TABLE usuarios ADD COLUMN estado VARCHAR(30) NOT NULL DEFAULT 'ACTIVO';`  
  (o el nombre/longitud que use Hibernate con @Enumerated STRING).

---

## PASO 6 — Commit y tag

```bash
VERSION="v0.11.0"
SLUG="registro-aprobacion-admin-estado"

git add gestion/src/main/java/com/gestion/qnt/model/enums/EstadoUsuario.java \
        gestion/src/main/java/com/gestion/qnt/model/Usuario.java \
        gestion/src/main/java/com/gestion/qnt/config/ApiConstants.java \
        gestion/src/main/java/com/gestion/qnt/config/SecurityConfiguration.java \
        gestion/src/main/java/com/gestion/qnt/security/controller/AuthRestController.java \
        gestion/src/main/java/com/gestion/qnt/security/controller/RegisterRequest.java \
        gestion/src/main/java/com/gestion/qnt/security/custom/CustomAuthenticationManager.java \
        gestion/src/main/java/com/gestion/qnt/repository/UsuarioRepository.java \
        gestion/src/main/java/com/gestion/qnt/model/business/interfaces/IUsuarioBusiness.java \
        gestion/src/main/java/com/gestion/qnt/model/business/UsuarioBusiness.java \
        gestion/src/main/java/com/gestion/qnt/controller/UsuarioRestController.java \
        gestion/src/main/java/com/gestion/qnt/controller/dto/AprobarUsuarioRequest.java \
        docs/COMO_PROBAR_API.md

git commit --no-verify -m "feat(auth): registro y aprobación por admin con estado explícito (Opción B)

- Enum EstadoUsuario: PENDIENTE_APROBACION, ACTIVO, DESACTIVADO
- Campo estado en Usuario; login solo si estado == ACTIVO
- POST /auth/register público; GET /usuarios/pendientes; PUT /usuarios/{id}/aprobar
- disable/enable sincronizan estado y activo
- Mensajes 403 diferenciados para pendiente vs desactivado"

git tag -a "${VERSION}" -m "Release v0.11.0: Registro y aprobación con estado explícito"
```

---

## Verificación final

- [ ] Usuario tiene campo estado (enum) y columna en BD; datos existentes con default ACTIVO.
- [ ] POST /auth/register crea usuario con estado PENDIENTE_APROBACION; email duplicado → 409.
- [ ] Login con PENDIENTE_APROBACION → 403 con mensaje de pendiente; con DESACTIVADO → 403 desactivada; con ACTIVO → 200 y token.
- [ ] GET /usuarios/pendientes (ADMIN) devuelve solo estado PENDIENTE_APROBACION.
- [ ] PUT /usuarios/{id}/aprobar asigna rol y pone estado ACTIVO; el usuario puede hacer login.
- [ ] disable/enable actualizan estado y activo correctamente.
- [ ] Build sin errores; rutas protegidas (register público, pendientes y aprobar solo ADMIN).

---

## Notas

- Roles ROLE_ADMIN, ROLE_PILOTO (o ROLE_USER) deben existir en tabla `roles`. Documentar o validar en aprobar.
- Opcional: en aprobar, rechazar si estado no es PENDIENTE_APROBACION para evitar re-aprobar o aprobar a un desactivado.
