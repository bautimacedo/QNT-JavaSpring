# v0.16.0 — Compras y Proveedores: controllers completos para frontend

**VERSIÓN:** v0.16.0  
**SLUG:** compras-proveedores-controllers-filtros  
**DEPENDENCIAS:** ninguna (Compra y Proveedor ya existen)  
**ESTIMACIÓN:** 2h  
**PRIORIDAD:** alta

---

## Objetivo

Dejar backend completamente listo para que el frontend pueda construir la pantalla de Compras y Proveedores. Estructura obligatoria: **los controllers solo llaman a métodos de negocio**; NUNCA acceden al repositorio directamente. Toda la lógica va en la capa de negocio (ICompraBusiness / IProveedorBusiness → CompraBusiness / ProveedorBusiness).

---

## Estado actual

- **Compra:** entidad OK, `CompraBusiness` con `list()`, `listFiltered(tipoCompra, proveedorId)`, `load()`, `add(request)`, `update(id, request)`, `update(entity)`, `delete()`. `CompraRepository` con queries JOIN FETCH. `CompraRestController` con GET, GET/{id}, POST, PUT/{id}, DELETE/{id}, PUT/{id}/imagen, GET/{id}/imagen.
- **Proveedor:** entidad OK, `ProveedorBusiness` con `list()`, `load(id)`, `loadOrCreate(nombre)`, `add()`, `update()`, `delete()`. **Falta** `ProveedorRestController` (no existe). **Falta** `load(nombre)` (buscar por nombre exacto) en IProveedorBusiness. **Falta** filtro de compras por fecha en el repository/business.
- **Stock/Inventario cuando tipoCompra = EQUIPO:** ya hay `// TODO Logica de Stock e Inventario` en CompraBusiness.add y update. **No tocar esa lógica.**

---

## PASO 1 — ProveedorRestController (crear desde cero)

Crear `com.gestion.qnt.controller.ProveedorRestController`. Base URL: `ApiConstants.URL_BASE + "/proveedores"`.  
Inyectar únicamente `IProveedorBusiness`. Todos los métodos delegan en el business. Estructura:

| Método | Ruta | Business | Rol | Notas |
|--------|------|----------|-----|-------|
| GET | `/proveedores` | `proveedorBusiness.list()` | ADMIN, USER | Lista todos los proveedores |
| GET | `/proveedores/{id}` | `proveedorBusiness.load(id)` | ADMIN, USER | 404 si no existe |
| GET | `/proveedores/search?nombre=` | `proveedorBusiness.loadByNombre(nombre)` | ADMIN, USER | 404 si no existe; útil para autocomplete en front |
| POST | `/proveedores` | `proveedorBusiness.add(entity)` | ADMIN, USER | Body: objeto Proveedor (nombre, cuit, contacto, direccion, telefono, email, observaciones) |
| PUT | `/proveedores/{id}` | `proveedorBusiness.update(entity)` | ADMIN, USER | 404 si no existe |
| DELETE | `/proveedores/{id}` | `proveedorBusiness.delete(id)` | ADMIN | 404 si no existe. Si el proveedor tiene compras asociadas, **devolver 409 Conflict** con mensaje "El proveedor tiene compras asociadas y no puede eliminarse" en lugar de lanzar excepción de constraint |

**Nota sobre DELETE:** En `ProveedorBusiness.delete(id)` verificar si `compraRepository.countByProveedorId(id) > 0` antes de borrar; si tiene compras, lanzar una excepción de negocio con ese mensaje (el controller la captura y devuelve 409). Inyectar `CompraRepository` (o `ICompraBusiness` si no quieres cruzar repos) en ProveedorBusiness solo para este check.

---

## PASO 2 — IProveedorBusiness: añadir `loadByNombre`

En `IProveedorBusiness` añadir:
```java
Proveedor loadByNombre(String nombre) throws NotFoundException, BusinessException;
```
En `ProveedorBusiness` implementar usando `ProveedorRepository.findFirstByNombreIgnoreCase(nombre)`.

---

## PASO 3 — CompraRestController: añadir filtro y endpoint de tipos

El controller ya tiene los endpoints base. Añadir/completar:

**3.1 GET /compras con filtros opcionales (query params):**

Reemplazar la firma actual:
```java
// ANTES
@GetMapping
public ResponseEntity<List<Compra>> list()

// AHORA
@GetMapping
public ResponseEntity<List<Compra>> list(
    @RequestParam(required = false) TipoCompra tipoCompra,
    @RequestParam(required = false) Long proveedorId)
```
Llamar a `compraBusiness.listFiltered(tipoCompra, proveedorId)`.  
Si ambos parámetros son null → devuelve todas las compras (comportamiento de `list()` anterior, ya cubierto por `listFiltered(null, null)` en el business).

**3.2 GET /compras/tipos (catálogo de tipos de compra para el dropdown del front):**

```java
@GetMapping("/tipos")
@PreAuthorize("hasRole('ADMIN') or hasRole('USER')")
public ResponseEntity<TipoCompra[]> getTipos() {
    return ResponseEntity.ok(TipoCompra.values());
}
```
Así el front obtiene los valores del enum dinámicamente y no los hardcodea.

**3.3 Verificar que los @Transactional estén donde corresponde:**
- GET list y GET /{id}: `@Transactional(readOnly = true)`.
- POST, PUT, DELETE: sin `@Transactional` en el controller (el business/repositorio ya maneja la transacción).

---

## PASO 4 — Proveedor: serialización (evitar LazyInitialization con compras)

En `Proveedor.java`, el campo `compras` es `FetchType.LAZY` y puede causar `LazyInitializationException` al serializar. Añadir `@JsonIgnore` en el campo `compras` para que no se serialice (el front no necesita ver todas las compras de un proveedor desde el endpoint de proveedor; las consulta desde `/compras?proveedorId=...`).

---

## PASO 5 — DTO de respuesta Compra (opcional pero recomendado)

Actualmente `Compra` serializa la entidad directamente. `proveedor` y `site` son LAZY y ya tienen JOIN FETCH en el repository (no hay LazyInitializationException). Verificar que en la respuesta JSON de `GET /compras` aparezcan:
- `proveedor` (con id, nombre, cuit al menos).
- `site` (con id, nombre, o null).
- `tieneImagenFactura` (boolean) — para que el front sepa si mostrar el ícono de descarga sin cargar la imagen completa. Añadir este campo como `@Transient` en `Compra` o calcularlo en el controller/business y meterlo en un DTO simple.

Si se usa DTO de respuesta, crear `CompraResumenResponse` con todos los campos de `Compra` excepto `imagenFactura`, más `tieneImagenFactura: boolean`. Esto es opcional; si el front puede manejar que `imagenFactura` no venga en el JSON (ya tiene `@JsonIgnore`), se puede postergar.

---

## PASO 6 — Validar que el TODO de Stock e Inventario está en el lugar correcto

Verificar que en `CompraBusiness.add` y `CompraBusiness.update(Long id, CreateCompraRequest request)` exista el bloque:
```java
if (compra.getTipoCompra() == TipoCompra.EQUIPO) {
    // TODO Logica de Stock e Inventario
}
```
**No implementar nada ahí.** Solo asegurarse de que el comentario está y que el bloque se ejecuta en el flujo correcto (después de setear todos los campos y antes del `repository.save`).

---

## PASO 7 — Documentar en INFORME_BACKEND_PARA_FRONTEND.md

Añadir/actualizar las secciones:

**Proveedores** (`/api/qnt/v1/proveedores`):

| Método | Ruta | Descripción | Rol |
|--------|------|-------------|-----|
| GET | `/proveedores` | Listar todos | ADMIN, USER |
| GET | `/proveedores/{id}` | Obtener por ID | ADMIN, USER |
| GET | `/proveedores/search?nombre=` | Buscar por nombre | ADMIN, USER |
| POST | `/proveedores` | Crear proveedor | ADMIN, USER |
| PUT | `/proveedores/{id}` | Actualizar proveedor | ADMIN, USER |
| DELETE | `/proveedores/{id}` | Eliminar (409 si tiene compras) | ADMIN |

**Compras** — actualizar tabla con el filtro:

| Método | Ruta | Descripción | Rol |
|--------|------|-------------|-----|
| GET | `/compras?tipoCompra=&proveedorId=` | Listar (ambos params opcionales) | ADMIN, USER |
| GET | `/compras/{id}` | Obtener por ID | ADMIN, USER |
| GET | `/compras/tipos` | Valores posibles de tipoCompra | ADMIN, USER |
| POST | `/compras` | Crear compra | ADMIN, USER |
| PUT | `/compras/{id}` | Actualizar compra | ADMIN, USER |
| DELETE | `/compras/{id}` | Eliminar | ADMIN |
| PUT | `/compras/{id}/imagen` | Subir imagen factura (multipart `file`) | ADMIN, USER |
| GET | `/compras/{id}/imagen` | Descargar imagen factura | ADMIN, USER |

---

## Verificación final

- [ ] `ProveedorRestController` existe con todos los endpoints del PASO 1.
- [ ] GET `/proveedores` lista proveedores sin LazyInitializationException (campo `compras` con @JsonIgnore).
- [ ] DELETE `/proveedores/{id}` devuelve 409 si tiene compras.
- [ ] GET `/compras?tipoCompra=LICENCIA_SW` filtra correctamente; sin params devuelve todas.
- [ ] GET `/compras/tipos` devuelve el array de valores del enum TipoCompra.
- [ ] TODO de Stock e Inventario existe en el flujo de add/update de CompraBusiness.
- [ ] INFORME_BACKEND_PARA_FRONTEND.md actualizado.
- [ ] Build sin errores.
