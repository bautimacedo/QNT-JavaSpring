# v0.4.0 ‚Äî Seguridad con JWT (login, filtro, configuraci√≥n)

**VERSI√ìN:** v0.4.0  
**SLUG:** security-jwt  
**DEPENDENCIAS:** v0.3.0 (Business con IUsuarioBusiness y load(String email))  
**ESTIMACI√ìN:** 2h 30min  
**PRIORIDAD:** alta

---

## Origen

> üóÇÔ∏è *Prompt generado por el Agente PM.*  
> *El cliente pidi√≥ implementar la seguridad de la aplicaci√≥n con JWT, siguiendo el patr√≥n de referencia proporcionado (SecurityConfiguration, AuthRestController, CustomAuthenticationManager, JWTAuthorizationFilter, AuthConstants). La API base es `/api/qnt/v1`.*

---

## Descripci√≥n

Implementar la **seguridad con JWT** en el m√≥dulo `gestion`:

1. **Configuraci√≥n de Spring Security**: sesi√≥n stateless, CORS, BCrypt, reglas de autorizaci√≥n (login y Swagger p√∫blicos; resto de `/api/qnt/v1/**` autenticado).
2. **Login**: endpoint POST que recibe email y contrase√±a, valida contra `IUsuarioBusiness` + `PasswordEncoder`, y devuelve un token JWT (text/plain).
3. **Filtro JWT**: leer token desde header `Authorization: Bearer <token>` o desde query param `authtoken`; verificar firma y expiraci√≥n; reconstruir el principal (usuario + roles) y setearlo en `SecurityContextHolder`.
4. **Autenticaci√≥n custom**: `AuthenticationManager` que usa `IUsuarioBusiness.load(String email)` y `PasswordEncoder.matches()` para validar credenciales.
5. **Constantes y secretos**: URL base de la API `/api/qnt/v1`; secret y tiempo de expiraci√≥n del JWT configurables v√≠a `application.properties` (no hardcodear el secret en producci√≥n).

**Patr√≥n de referencia:** Los archivos que el cliente proporcion√≥ (SecurityConfiguration, AuthRestController, CustomAuthenticationManager, JWTAuthorizationFilter, AuthConstants, BadPasswordException). Adaptar paquetes a `com.gestion.qnt` y entidades a `Usuario` / `Role` de este proyecto. Login por **email** (el modelo usa `Usuario` con `email` √∫nico e `IUsuarioBusiness.load(String email)`).

**Alcance excluido en este ticket:** registro de usuarios, refresh token, bloqueo por intentos fallidos, validaciones tipo ‚Äúcuenta expirada‚Äù (se pueden a√±adir despu√©s). Solo login + protecci√≥n de rutas con JWT.

---

## PASO 0 ‚Äî Contexto previo a leer

> ‚ö†Ô∏è Si ven√≠s del AGENTE_WORKFLOW.md, saltear este paso.

Leer sin ejecutar nada:

- `gestion/src/main/java/com/gestion/qnt/model/Usuario.java` ‚Äî entidad con id, email, password, roles (List<Role>).
- `gestion/src/main/java/com/gestion/qnt/model/Role.java` ‚Äî entidad con id, codigo, nombre.
- `gestion/src/main/java/com/gestion/qnt/model/business/interfaces/IUsuarioBusiness.java` ‚Äî tiene `Usuario load(String email)`.
- `gestion/pom.xml` ‚Äî confirmar que existe `spring-boot-starter-security`; agregar dependencia para JWT (ver PASO 1).

---

## PASO 1 ‚Äî Dependencia JWT

En `gestion/pom.xml` agregar la dependencia para generar y validar JWT (por ejemplo **auth0** java-jwt):

```xml
<!-- JWT -->
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.4.0</version>
</dependency>
```

**Verificaci√≥n:** `mvn -f gestion/pom.xml dependency:resolve` sin errores.

---

## PASO 2 ‚Äî Constantes de la API y auth

Crear una clase de constantes para URLs y nombres de endpoints, por ejemplo en `com.gestion.qnt.config` o `com.gestion.qnt.controller`:

- `URL_BASE = "/api/qnt/v1"`
- `URL_LOGIN = "/api/qnt/v1/auth/login"` (o `URL_BASE + "/auth/login"`)

Crear en `com.gestion.qnt.security` (o `com.gestion.qnt.auth.filters`) la clase **AuthConstants** (o equivalente) con:

- `AUTH_HEADER_NAME = "Authorization"`
- `AUTH_PARAM_NAME = "authtoken"`
- `TOKEN_PREFIX = "Bearer "`
- `EXPIRATION_TIME` y `SECRET`: **no hardcodear en producci√≥n**. Leer desde configuraci√≥n (ver m√°s abajo). Para desarrollo se pueden definir valores por defecto en la clase si no est√°n en `application.properties`.

En `gestion/src/main/resources/application.properties` (o `application-dev.properties`) agregar:

```properties
# JWT (en producci√≥n usar variables de entorno o secret manager)
jwt.secret=MyVerySecretKeyChangeInProduction
jwt.expiration-ms=3600000
```

`EXPIRATION_TIME` en ms (ej. 3600000 = 1 hora). La clase AuthConstants puede leer estas propiedades v√≠a `@Value` si se convierte en un `@Component`, o se inyectan donde se construyan el token y el filtro (ver PASO 5 y 6).

---

## PASO 3 ‚Äî Principal de seguridad (User / AuthUser)

Spring Security necesita un **principal** (objeto que representa al usuario autenticado) con al menos nombre y autoridades. Opciones:

- **A)** Crear una clase **AuthUser** (o **SecurityUser**) en `com.gestion.qnt.security` que contenga: `id` (Long), `username` (String, puede ser el email), `email` (String), `roles` como lista de c√≥digos o como `Collection<? extends GrantedAuthority>`. No anotar como entidad JPA; es un DTO para el contexto de seguridad.  
- **B)** Usar la entidad `Usuario` como principal: asegurarse de que en el filtro y en el login se pueda obtener `GrantedAuthority` desde `usuario.getRoles()` (ej. `role.getCodigo()` como nombre del authority).

Recomendaci√≥n: **AuthUser** (o similar) con id, email (como username), lista de authorities construida desde `Usuario.getRoles()` (mapear `Role.getCodigo()` a `SimpleGrantedAuthority`). As√≠ no se expone la entidad JPA ni se fuerza lazy loading en el filtro.

Implementar en el **CustomAuthenticationManager** (PASO 4): despu√©s de cargar `Usuario` por email y validar contrase√±a, construir este principal y devolverlo en `UsernamePasswordAuthenticationToken(user, null, authorities)`.

---

## PASO 4 ‚Äî CustomAuthenticationManager

Crear en `com.gestion.qnt.security.custom` (o `com.gestion.qnt.auth.custom`) la clase **CustomAuthenticationManager** que implemente `AuthenticationManager`:

- Constructor (o inyecci√≥n) con `PasswordEncoder` e `IUsuarioBusiness`.
- M√©todo **authenticate(Authentication authentication)**:
  - Obtener nombre (email) y credencial (password) del `Authentication` recibido.
  - Llamar `usuarioBusiness.load(email)`; si lanza `NotFoundException` ‚Üí lanzar `BadCredentialsException` (no revelar si el usuario existe o no).
  - Si lanza `BusinessException` ‚Üí log y lanzar `AuthenticationServiceException`.
  - Verificar contrase√±a con `passwordEncoder.matches(rawPassword, usuario.getPassword())`; si no coincide ‚Üí `BadCredentialsException`.
  - Opcional: validaciones adicionales (cuenta deshabilitada, expirada, etc.) si en el futuro se agregan campos a Usuario; por ahora no es obligatorio.
  - Construir el principal (AuthUser o Usuario con autoridades) y devolver `new UsernamePasswordAuthenticationToken(principal, null, authorities)`.

- M√©todo **authWrap(String name, String pass)**: devolver una implementaci√≥n an√≥nima de `Authentication` donde `getName()` devuelve `name`, `getCredentials()` devuelve `pass`, `isAuthenticated()` false, y el resto null/empty. Sirve para que el controlador de login pase solo usuario y contrase√±a al `authenticate()`.

**Verificaci√≥n:** la clase compila y usa `com.gestion.qnt.model.business.interfaces.IUsuarioBusiness` y `com.gestion.qnt.model.Usuario`.

---

## PASO 5 ‚Äî Filtro JWT (JWTAuthorizationFilter)

Crear en `com.gestion.qnt.security.filters` (o `com.gestion.qnt.auth.filters`) la clase **JWTAuthorizationFilter** que extienda `BasicAuthenticationFilter`:

- Constructor que reciba `AuthenticationManager` y llame a `super(authenticationManager)`.
- **doFilterInternal**: 
  - Leer token del header `Authorization` (si empieza con "Bearer ") o del par√°metro de request `authtoken`.
  - Si no hay token v√°lido (null o longitud m√≠nima) ‚Üí `chain.doFilter(req, res)` y return.
  - Si hay token: llamar a un m√©todo privado **getAuthentication(request, byHeader)** que extraiga el token, lo verifique con la librer√≠a JWT (mismo secret y algoritmo que en el login), lea claims (subject = email/username, internalId, roles, email) y construya un `UsernamePasswordAuthenticationToken` con el principal (AuthUser o similar) y las autoridades. Si la verificaci√≥n falla (token expirado o inv√°lido) ‚Üí no setear autenticaci√≥n y continuar la cadena (o devolver 401; seg√∫n criterio, normalmente se deja seguir y las rutas protegidas devolver√°n 401).
  - Setear el resultado en `SecurityContextHolder.getContext().setAuthentication(authentication)` y luego `chain.doFilter(req, res)`.

El **secret** y, si aplica, la **expiraci√≥n** usados para `JWT.require(Algorithm.HMAC512(secret)).build().verify(token)` deben ser los mismos que en el login e idealmente le√≠dos de configuraci√≥n (ver PASO 2). Si AuthConstants es un bean con `@Value`, inyectarlo en el filtro; si no, pasar el secret al filtro desde la configuraci√≥n de seguridad.

**Verificaci√≥n:** el filtro compila y usa `AuthConstants` (o la fuente de secret/expiration que se haya definido).

---

## PASO 6 ‚Äî Controlador de autenticaci√≥n (AuthRestController)

Crear en `com.gestion.qnt.security.controller` (o `com.gestion.qnt.auth.controller`) un **AuthRestController** (o **AuthController**):

- **POST** al endpoint de login (ej. `URL_LOGIN` = `/api/qnt/v1/auth/login`): 
  - Par√°metros: `username` (en realidad ser√° el email) y `password` (por form o query param; el cliente de referencia usa `@RequestParam`).
  - Llamar `authenticationManager.authenticate(customAuthManager.authWrap(username, password))`.
  - Si devuelve `Authentication`, tomar el principal y generar el JWT con la librer√≠a (ej. `JWT.create().withSubject(principal.getUsername()).withClaim("internalId", id).withClaim("roles", listaDeRoles).withClaim("email", email).withExpiresAt(...).sign(Algorithm.HMAC512(secret))`).
  - Respuesta: cuerpo = token (text/plain), status 200. En caso de `AuthenticationException` ‚Üí 401 con mensaje; en caso de `AuthenticationServiceException` ‚Üí 500.

- **GET** `/api/qnt/v1/auth/me`: devolver el principal actual (`Authentication.getPrincipal()`) para que el cliente pueda obtener los datos del usuario logueado. Protegido por defecto (requiere token).

- Opcional **GET** `/api/qnt/v1/demo/encodepass?password=xxx`: para desarrollo, devolver `passwordEncoder.encode(password)` en texto plano; √∫til para generar contrase√±as hasheadas. Dejar esta ruta en la lista de permitAll solo en desarrollo o eliminarla en producci√≥n.

Inyectar `AuthenticationManager` (el bean CustomAuthenticationManager), `PasswordEncoder` y, si se usa, un bean de respuesta est√°ndar para errores. Las constantes de URL deben coincidir con las usadas en SecurityConfiguration.

**Verificaci√≥n:** el controlador compila y las rutas son las definidas en Constants/URL_BASE.

---

## PASO 7 ‚Äî SecurityConfiguration

Crear en `com.gestion.qnt.config` (o `com.gestion.qnt.security`) la clase **SecurityConfiguration** (o **WebSecurityConfig**):

- Anotaciones: `@Configuration`, `@EnableWebSecurity`, `@EnableMethodSecurity(prePostEnabled = true)`.
- **Beans:**
  - **PasswordEncoder**: `BCryptPasswordEncoder` (por ejemplo m√©todo `bCryptPasswordEncoder()`).
  - **CorsConfigurationSource**: configurar or√≠genes permitidos (lista de dominios del front; en dev se puede usar "http://localhost:5173" o similar), m√©todos `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS`, headers permitidos `*`, exposed headers incluyendo `Authorization`, `allowCredentials(true)`. Registrar esta configuraci√≥n para `URL_BASE + "/**"` (ej. `/api/qnt/v1/**`). Si hay WebSocket u otras rutas p√∫blicas, registrarlas tambi√©n.
  - **AuthenticationManager**: instancia de `CustomAuthenticationManager` con el `PasswordEncoder` e `IUsuarioBusiness` inyectados.
- **SecurityFilterChain**:
  - Usar `cors(cors -> cors.configurationSource(corsConfigurationSource()))`.
  - Deshabilitar CSRF (`csrf(AbstractHttpConfigurer::disable)`).
  - **authorizeHttpRequests**: 
    - `requestMatchers(HttpMethod.POST, URL_LOGIN).permitAll()`
    - `requestMatchers("/v3/api-docs/**", "/swagger-ui.html", "/swagger-ui/**").permitAll()`
    - `requestMatchers(URL_BASE + "/demo/**").permitAll()` (para encodepass u otros endpoints de demo si se implementaron)
    - `anyRequest().authenticated()`
  - **sessionManagement**: `sessionCreationPolicy(SessionCreationPolicy.STATELESS)`.
  - **addFilter**: instanciar y agregar `JWTAuthorizationFilter(authenticationManager())`.

Asegurarse de que la URL base sea exactamente `/api/qnt/v1` y que el filtro JWT se aplique a todas las peticiones que requieran autenticaci√≥n.

**Verificaci√≥n:** la aplicaci√≥n arranca sin errores y una petici√≥n POST al login con email y contrase√±a correctos devuelve un token; una petici√≥n GET a `/api/qnt/v1/auth/me` con header `Authorization: Bearer <token>` devuelve los datos del usuario.

---

## PASO 8 ‚Äî Excepci√≥n opcional BadPasswordException

Si se desea una excepci√≥n propia para contrase√±a inv√°lida (en lugar de usar solo `BadCredentialsException`), crear en `com.gestion.qnt.security` (o `com.gestion.qnt.auth`) la clase **BadPasswordException** que extienda `Exception`, con constructores que reciban mensaje y/o causa (por ejemplo con Lombok `@Builder`). No es obligatorio; el flujo puede basarse solo en `BadCredentialsException` de Spring.

---

## PASO 9 ‚Äî Verificaci√≥n final

- [ ] Login POST con email y contrase√±a v√°lidos devuelve un token JWT (text/plain).
- [ ] Peticiones a `/api/qnt/v1/auth/me` con header `Authorization: Bearer <token>` devuelven el principal (usuario logueado).
- [ ] Peticiones a cualquier ruta protegida sin token (o con token inv√°lido/expirado) devuelven 401.
- [ ] Swagger y rutas de login/demo est√°n en permitAll y funcionan sin token.
- [ ] Secret y expiraci√≥n del JWT est√°n configurados v√≠a `application.properties` (o variables de entorno) y no hardcodeados en c√≥digo de producci√≥n.
- [ ] Build sin errores: `mvn -f gestion/pom.xml clean compile` y arranque de la aplicaci√≥n OK.

---

## PASO N ‚Äî Commit y tag

```bash
VERSION="v0.4.0"
SLUG="security-jwt"

git add gestion/pom.xml \
       gestion/src/main/java/com/gestion/qnt/config/ \
       gestion/src/main/java/com/gestion/qnt/security/ \
       gestion/src/main/java/com/gestion/qnt/auth/ \
       gestion/src/main/resources/application.properties

git commit --no-verify -m "feat(security): autenticaci√≥n JWT y configuraci√≥n Spring Security

- SecurityConfiguration: stateless, CORS, BCrypt, JWT filter
- AuthRestController: POST login (email/password -> token), GET /auth/me
- CustomAuthenticationManager con IUsuarioBusiness y PasswordEncoder
- JWTAuthorizationFilter: token por header Bearer o query param authtoken
- AuthConstants y configuraci√≥n jwt.secret / jwt.expiration-ms
- URL base API: /api/qnt/v1"

git tag -a "${VERSION}" -m "Release v0.4.0: Seguridad JWT"
```

(Ajustar rutas de `git add` seg√∫n los paquetes reales usados: config, security, auth.)

---

## Notas

- **Login por email:** En este proyecto el identificador de login es el **email** (Usuario tiene email √∫nico). El par√°metro del endpoint puede llamarse `username` por convenci√≥n de Spring pero el valor que se debe enviar es el email.
- **Principal:** Usar un DTO (AuthUser/SecurityUser) con id, email, authorities para el SecurityContext evita exponer la entidad JPA y problemas de lazy loading.
- **Secret en producci√≥n:** No commitear un secret real en `application.properties`. Usar variables de entorno (ej. `JWT_SECRET`) o un secret manager y leer con `@Value("${jwt.secret}")`.
- **CORS:** Dejar la lista de or√≠genes permitidos configurable (por ejemplo `application.properties` con `cors.allowed-origins`) para distintos entornos (dev, staging, prod).
- Si el proyecto usa un `BaseRestController` o manejo est√°ndar de respuestas de error (como en la referencia con `IStandartResponseBusiness`), reutilizarlo en el controlador de auth para respuestas 401/500; si no existe, devolver ResponseEntity con cuerpo simple (mensaje o mapa).
