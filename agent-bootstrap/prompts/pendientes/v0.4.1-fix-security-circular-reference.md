# v0.4.1 ‚Äî Corregir dependencia circular SecurityConfiguration ‚Üî CustomAuthenticationManager

**VERSI√ìN:** v0.4.1  
**SLUG:** fix-security-circular-reference  
**DEPENDENCIAS:** v0.4.0 (seguridad JWT ya implementada)  
**ESTIMACI√ìN:** 15‚Äì20 min  
**PRIORIDAD:** alta

---

## Origen

> üóÇÔ∏è *Prompt generado por el Agente PM.*  
> *Al arrancar la aplicaci√≥n con `./mvnw spring-boot:run` falla con "The dependencies of some of the beans in the application context form a cycle" entre `securityConfiguration` y `customAuthenticationManager`. Hay que romper el ciclo sin desactivar la seguridad.*

---

## Descripci√≥n del problema

Spring Boot informa un ciclo de dependencias:

```
securityConfiguration
    ‚Üë     ‚Üì
customAuthenticationManager
```

- **SecurityConfiguration** (constructor) necesita **CustomAuthenticationManager**.
- **CustomAuthenticationManager** (constructor) necesita **PasswordEncoder**.
- El bean **PasswordEncoder** est√° definido **dentro de SecurityConfiguration** (`@Bean passwordEncoder()`).

Para crear `SecurityConfiguration`, Spring debe inyectar `CustomAuthenticationManager`; para crear `CustomAuthenticationManager`, debe inyectar `PasswordEncoder`; ese `PasswordEncoder` lo aporta un m√©todo de `SecurityConfiguration`, por lo que Spring intenta crear `SecurityConfiguration` primero. Eso genera la dependencia circular.

**Objetivo:** Romper el ciclo sin usar `spring.main.allow-circular-references=true`. La soluci√≥n correcta es sacar el bean `PasswordEncoder` de `SecurityConfiguration` y definirlo en otra clase de configuraci√≥n que no dependa de `CustomAuthenticationManager`.

---

## PASO 0 ‚Äî Contexto previo a leer

> ‚ö†Ô∏è Si ven√≠s del AGENTE_WORKFLOW.md, saltear este paso.

Leer sin ejecutar nada:

- `gestion/src/main/java/com/gestion/qnt/config/SecurityConfiguration.java` ‚Äî comprobar que tiene `@Bean passwordEncoder()` y constructor con `CustomAuthenticationManager`.
- `gestion/src/main/java/com/gestion/qnt/security/custom/CustomAuthenticationManager.java` ‚Äî comprobar que inyecta `PasswordEncoder` e `IUsuarioBusiness`.

---

## PASO 1 ‚Äî Crear una clase de configuraci√≥n solo para PasswordEncoder

Crear una nueva clase en `com.gestion.qnt.config` (o en `com.gestion.qnt.security.config`) llamada por ejemplo **PasswordEncoderConfig**:

- Anotaci√≥n `@Configuration`.
- Un √∫nico m√©todo `@Bean` que devuelva `org.springframework.security.crypto.password.PasswordEncoder`, instanciando `org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder()`.

Ejemplo:

```java
package com.gestion.qnt.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordEncoderConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

**Verificaci√≥n:** La clase compila. El bean `passwordEncoder` queda registrado en el contexto de Spring desde esta configuraci√≥n.

---

## PASO 2 ‚Äî Quitar el bean PasswordEncoder de SecurityConfiguration

En **SecurityConfiguration**:

- Eliminar por completo el m√©todo `passwordEncoder()` (el `@Bean` que devuelve `BCryptPasswordEncoder`).
- No inyectar `PasswordEncoder` en `SecurityConfiguration` a menos que alg√∫n otro bean de esa clase lo use (en el c√≥digo actual solo lo usa `CustomAuthenticationManager`, que ya lo inyecta por su cuenta).

De este modo, `SecurityConfiguration` deja de ser el proveedor del bean `PasswordEncoder` y el ciclo se rompe: primero se crea `PasswordEncoderConfig` y el bean `PasswordEncoder`, luego `CustomAuthenticationManager` (que recibe `PasswordEncoder` e `IUsuarioBusiness`), y por √∫ltimo `SecurityConfiguration` (que recibe `AuthConstants`, `CustomAuthenticationManager` y `Environment`).

**Verificaci√≥n:** No queden referencias a `PasswordEncoder` dentro de `SecurityConfiguration` que obliguen a definir el bean ah√≠. Si en el mismo archivo se usara `passwordEncoder()` en alg√∫n otro m√©todo, usar en su lugar la inyecci√≥n del bean por constructor o por par√°metro de m√©todo seg√∫n corresponda.

---

## PASO 3 ‚Äî Verificaci√≥n

- [ ] Existe una clase `PasswordEncoderConfig` (o nombre equivalente) con `@Bean PasswordEncoder`.
- [ ] `SecurityConfiguration` ya no define el m√©todo `passwordEncoder()`.
- [ ] La aplicaci√≥n arranca sin error: `./mvnw spring-boot:run` desde el directorio `gestion/` termina con "Started GestionApplication" y no aparece el error de dependencia circular.
- [ ] El login sigue funcionando (POST `/api/qnt/v1/auth/login` con email y contrase√±a correctos devuelve un token JWT).

---

## PASO N ‚Äî Commit y tag

```bash
VERSION="v0.4.1"
SLUG="fix-security-circular-reference"

git add gestion/src/main/java/com/gestion/qnt/config/

git commit --no-verify -m "fix(security): romper dependencia circular SecurityConfiguration / CustomAuthenticationManager

- PasswordEncoder movido a PasswordEncoderConfig
- SecurityConfiguration deja de definir el bean passwordEncoder
- Arranque de la aplicaci√≥n sin ciclo de beans"

git tag -a "${VERSION}" -m "Release v0.4.1: Fix circular reference en seguridad"
```

---

## Notas

- No usar `spring.main.allow-circular-references=true` en `application.properties` como soluci√≥n; enmascara el problema y puede dar comportamientos raros.
- Si en el proyecto ya existiera otra clase de configuraci√≥n que defina `PasswordEncoder` (por ejemplo un `SecurityBeansConfig`), reutilizarla y solo eliminar el m√©todo duplicado de `SecurityConfiguration`.
- Despu√©s del cambio, `CustomAuthenticationManager` sigue recibiendo el mismo tipo `PasswordEncoder` desde el contexto; solo cambia la clase que declara el `@Bean`.
